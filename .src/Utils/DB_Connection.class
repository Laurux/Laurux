' Gambas class file

Inherits Connection

Private log As ComplexLogger
Private logh As Collection
Private hFile As File
Private hFilePath As String

Private user_name As String = Left$(User.name, 50)
Private process_id As Integer = Application.Id
Private machine_id As String
Private host_id As String
Private AllFilters As String
Private Filtering As Boolean
Private Filter_Error As String

Private Filters As Collection


Public Sub _new()
  
  Dim host_name As String
  
  Shell "cat /etc/machine-id" To machine_id
  Shell "hostname" To host_name
  Shell "hostid" To host_id
  machine_id = Left$(Trim$(machine_id), 50)
  host_id = Left$(Trim$(host_name) & "(" & Trim$(host_id) & ")", 50)
  
  Filters = New Collection
  'On ne loggue pas par default, on clear en cas de logging au boot pour eventuellement effacer fichier de log existant
  'On devrait activer le log automatique soit depuis les prefs
  'soit depuis les arguments de la ligne de commande
  Start(Start.Arg_Log, Start.Arg_Log)
  
End


Public Sub Start(Optional Enabling As Boolean = False, Optional Clear As Boolean = False)
  
  Dim handler, handler_r As LogHandler
  Dim logout As String = ""
  Dim remote_host As String
  Dim remote_port As Integer
  
  If Start.Arg_Replay Then
    logout = ".out"
  Endif
  Filter_Error = ""
  Get_Filter()
  Refresh_Filter()
  If IsNull(Start.Arg_LogFile) Then
    If Not Exist(User.home & "/tmp") Then Mkdir User.home & "/tmp"
    hFilePath = User.Home & "/tmp/" & Application.Name & ".log" & logout
  Else
    hFilePath = Start.Arg_LogFile & logout
  Endif
  If Clear = True Then
    Try Kill hFilePath
  Endif
  logh = New Collection
  handler = New FileHandler(hFilePath, Logger.Info)
  logh.Add(handler, "local")
  log = New ComplexLogger("$(now);$(levelname);$(message)", logh["local"])
  remote_host = Start.LocalSettings["/Soc" & Start.Societe & "/ServerLogIP"]
  If Not IsNull(Start.LocalSettings["/Soc" & Start.Societe & "/ServerLogPort"]) Then
    If (Start.LocalSettings["/Soc" & Start.Societe & "/ServerLogPort"] >= 1024) And (Start.LocalSettings["/Soc" & Start.Societe & "/ServerLogPort"] < 65536) Then
      remote_port = Start.LocalSettings["/Soc" & Start.Societe & "/ServerLogPort"]
    Else
      remote_port = 0
    Endif
  Else
    remote_port = 0
  Endif
  If (remote_host <> Null) Or (remote_port <> 0) Then
    handler_r = New NetHandler(remote_host, remote_port, Logger.Info)
    logh.Add(handler_r, "remote")
    log.addHandler(logh["remote"])
  Endif
  'logger is not enabled before begin is done
  'to avoid logging event during logger start
  log.Enabled = False
  log.Begin()
  log.Enabled = Enabling

End


Public Sub Clear()

  Dim state As Boolean
  
  If log <> Null Then
    state = log.Enabled
    log.Close()
    Start(state, True)
  Endif
  
End


Public Sub Refresh()

  Dim state As Boolean
  
  If log <> Null Then
    state = log.Enabled
    log.Close()
    Start(state, False)
  Endif
  
End

Public Sub Set_Log(boo As Boolean)
  
  log.Enabled = boo
  
End

Public Sub Enable_Log()
  
  Set_Log(True)
  
End

Public Sub Disable_Log()
  
  Set_Log(False)
  
End

Public Sub Get_Log() As Boolean
  
  Return log.Enabled
  
End

Public Sub Get_Filter() As String
  
  Dim filterlist As String
  
  hFilePath = Temp$(Application.Name & "_filter")
  Try AllFilters = File.Load(hFilePath)
  If Error Then AllFilters = ""
  Return AllFilters
  
End


Public Sub Set_Filter(filterlist As String)
  
  hFilePath = Temp$(Application.Name & "_filter")
  File.Save(hFilePath, filterlist)
  AllFilters = filterlist
  Refresh()
  
End

Public Sub Refresh_Filter()

  Dim filter As String
  Dim i As Integer = 0
  Dim temp_regex As RegExp
  Dim Key, Rx As String
  Dim Aregex As RegExp[]
  Dim pos As Integer

  Filtering = False
  Filters.Clear()

  For Each filter In Split(AllFilters, "\n")
    pos = InStr(filter, ":")
    If pos = 0 Then
      Filter_Error &= "\n=> " & Now & "Echec: le Filtre " & filter & " ne respecte pas le format!"
    Endif
    Key = Left$(filter, pos - 1)
    Rx = Right$(filter, Len(filter) - pos)
    temp_regex = New RegExp
    Try temp_regex.Compile(Rx) 'on fait le try sur une regex temporaire sinon l'Eval en dessous fail !!! Bug ???
    If Error Then
      Filter_Error &= "\n=> " & Now & "Echec: Impossible de compiler le Filtre " & key & " : " & Error.Text
    Else
      Filtering = True
      If Filters[Key] = Null Then
        Aregex = New RegExp[]
        Aregex.Add(temp_regex)
        Filters.Add(Aregex, Key)
      Else
        Filters[Key].Add(temp_regex)
      Endif
      i = i + 1
    Endif
  Next
  
  Filter_Error &= "\n=> " & Now & "Nombre de Filtres Analysé :" & i

End


Public Sub Get_Filter_Error() As String
  
  Return Filter_Error
  
End


Public Sub Get_Localfile_Path() As String
  
  Return logh["local"].GetOutput()
  
End


Public Sub Get_Remotefile_Path() As String

  Dim out As String
  If logh["remote"] = Null
    Return "Remote logger pas configuré (voir prefs)"
  Endif
  
  out = logh["remote"].GetOutput()
  If Left(out, 4) = "Fail" Then
    Return out & "\n  Sur le serveur executez la commande: nc -l -k -p [port_nb] > laurux_log.csv"
  Else
    Return out
  Endif
  
End


Public Sub Is_Filtered(FilterName As String, Request As String) As Boolean
  
  Dim Found As Boolean = False
  Dim Aregex As RegExp[]
  Dim regex As RegExp
  
  If log.Enabled = False Then Return False
  If Filtering = False Then Return True 'If no Filter exist just accept all
  
  If Filters[FilterName] <> Null Then
    For Each regex In Filters[FilterName]
      Try regex.Exec(Request)
      If Error Then Filter_Error &= "\n=> " & Now & "Echec a l'execution du Filtre " & FilterName & " : " & Error.Text
      If regex.Count >= 0 Then
        Found = True
      Endif
    Next
  Endif
  
  Return Found
  
End

Public Sub Engine() As String
  
  If Super.Type = "mysql" Then
    Return " ENGINE = InnoDB" '"MYISAM"
  Else
    Return ""
  Endif
  
End

Public Sub AutoIncrement(Optional Fld As String = "lind", Optional Type As String = "INT", Optional Size As Integer = -1) As String
  
  If Super.Type = "mysql" Then
    If (Size > 0) Then
      Type = Type & "(" & CStr(Size) & ")"
    Endif
    Return Fld & " " & Type & " NOT NULL AUTO_INCREMENT, PRIMARY KEY (" & Fld & ")"
  Else
    Return Fld & " INTEGER PRIMARY KEY AUTOINCREMENT"
  Endif
  
End


Public Sub Exec(Request As String, ...) As Result 
  
  Dim rResult As Result
  Dim aArg As Variant[]
  Dim oneArg As Variant
  Dim Backtrace As String[]
  Dim iInd As Integer
  Dim regex As RegExp
  Dim filling As String
  Dim i As Integer
  Dim patrn As String

  'This should work but it doen't because Param is a class... not a Argument Array.
  'rResult = Super.Exec(Request, Param)
  'Workaround below

  If Param.Count Then
    aArg = New Variant[Param.Count + 1]
    aArg[0] = Request
    iInd = 1
    For Each oneArg In Param
      aArg[iInd] = oneArg
      iInd += 1
    Next
    'Seul moyen trouvé pour executer une fonction a arg variable depuis une fonction a arg variable
    Request = Object.Call(Me, "Subst", aArg)
  Endif

  If Is_Filtered("Exec_SQL", Request) = True Then
    Backtrace = System.Backtrace
    Backtrace.Extract(Backtrace.Length - 1, -1)
    Backtrace.Extract(0, 1)
    If log.Enabled Then
      log.Log("Exec_SQL;" & user_name & ";" & host_id & ";" & machine_id & ";" & process_id & ";" & Backtrace.Join(",") & ";" & Request)
    Endif
  Endif
  
  regex = New RegExp
  If Super.type = "sqlite3" Then
    'Disable locking mecanism in sqlite3
    If UCase(Request) Match "LOCK TABLES" Then Return Null
    If UCase(Request) Match "UNLOCK TABLES" Then Return Null
    ''Transforme la syntaxe mysql en sqlite
    'Les dates
    If UCase(Request) Match "YEAR" Then Request = regex.Replace(Request, "YEAR *\\(([()'. a-zA-Z0-9_-]+)\\)", "strftime('%Y',&1) ", regex.Caseless)
    If UCase(Request) Match "MONTH" Then Request = regex.Replace(Request, "MONTH *\\(([()'. a-zA-Z0-9_-]+)\\)", "strftime('%m',&1) ", regex.Caseless)
    If UCase(Request) Match "DAY" Then Request = regex.Replace(Request, "DAY *\\(([()'. a-zA-Z0-9_-]+)\\)", "strftime('%d',&1) ", regex.Caseless)
    If UCase(Request) Match "NOW" Then Request = regex.Replace(Request, "NOW *\\(\\)", "strftime('%Y-%m-%d','now') ", regex.Caseless)
    'la concatenation à 2 arguments => est il possible de faire + ?
    If UCase(Request) Match "CONCAT" Then 
      Request = regex.Replace(Request, "CONCAT\\(([()'. a-zA-Z0-9_éèàêâù%-]+) *, *([()'. a-zA-Z0-9_éèàêâù%-]+)\\)", "&1 || &2 ", regex.Caseless)
    Endif 
    'les chaines
    If UCase(request) Match "LEFT" Then Request = regex.Replace(Request, "left\\(([().' a-zA-Z0-9_-]+) *, *([0-9-]+)\\)", "substr(&1,0,&2) ", regex.Caseless)
    If UCase(request) Match "RIGHT" Then Request = regex.Replace(Request, "right\\(([()'. a-zA-Z0-9_-]+) *, *([0-9-]+)\\)", "substr(&1,-&2) ", regex.Caseless)
    If UCase(request) Match "MID" Then Request = regex.Replace(Request, "mid\\(([().' a-zA-Z0-9_-]+) *, *([0-9-]+) *, *([0-9-]+)\\)", "substr(&1,&2,&3) ", regex.Caseless)
    'null 
    If UCase(Request) Match "ISNULL" Then request = regex.Replace(Request, "isnull\\(([()' .a-zA-Z0-9_-]+)\\)", "&1 IS NULL", regex.Caseless)
    'lpad case
    '---------
    Try regex.Compile("lpad[(]([^,]+)[,]+([^,]+)[,]+([^,]+)[)]")
    If Error Then Message.Error("Echec a la compilation du Filtre lpad :" & Error.Text)
    Try regex.Exec(Request)
    If Error Then Message.Error("Echec a l'execution du Filtre lpad :" & Error.Text)
    If regex.Count >= 1 Then
      If (regex.Count <> 3) Then
        Message.Error("Unsupported sqlite3 lpad request conversion format")
      Else
        'Message.Info("Found!")
        For i = 1 To regex[2].Text Step 1
          filling &= Chr(Asc(regex[3].Text, 2))
        Next
        Request = Replace(Request, regex[0].Text, "substr('" & filling & "' || " & regex[1].Text & ", -" & regex[2].Text & ", " & regex[2].Text & ")")
      Endif
      'substr( '0000000000' || mycolumn, -10, 10)
      'replace(replace(substr(quote(zeroblob((7 + 1) / 2)), 3, (7 - length("foo"))), "'", ""), "0", "W");
    Endif
    'left case
    '---------
    Try regex.Compile("left[(]([^,]+)[,]+([^,]+)[)]")
    If Error Then Message.Error("Echec a la compilation du Filtre left :" & Error.Text)
    Try regex.Exec(Request)
    If Error Then Message.Error("Echec a l'execution du Filtre left :" & Error.Text)
    If regex.Count >= 1 Then
      If (regex.Count <> 2) Then
        Message.Error("Unsupported sqlite3 left request conversion format")
      Else
        'Message.Info("Found!")
        Request = Replace(Request, regex[0].Text, "substr(" & regex[1].Text & ",0," & CStr(Val(regex[2].Text) + 1) & ")")
      Endif
    Endif
    'right case
    '---------
    Try regex.Compile("right[(]([^,]+)[,]+([^,]+)[)]")
    If Error Then Message.Error("Echec a la compilation du Filtre right :" & Error.Text)
    Try regex.Exec(Request)
    If Error Then Message.Error("Echec a l'execution du Filtre right :" & Error.Text)
    If regex.Count >= 1 Then
      If (regex.Count <> 2) Then
        Message.Error("Unsupported sqlite3 right request conversion format")
      Else
        'Message.Info("Found!")
        Request = Replace(Request, regex[0].Text, "substr(" & regex[1].Text & ",length(" & regex[1].Text & ")-" & CStr(Val(regex[2].Text) - 1) & ")")
      Endif
    Endif
    'conversion
    If UCase(request) Match "ABS" Then Request = regex.Replace(request, "abs\\(([()'.,|a-zA-Z0-9_ -]+)\\) ", "CAST(&1) AS INTEGER) ", regex.Caseless)
    'Special stuff for sqlite, does not handle properly case sensitive data on selection / update
    If UCase(Request) Match "WHERE" Then
      i = InStr(UCase(Request), "ORDER")
      If i > 0 
        Request = Left$(Request, i - 1) & " COLLATE NOCASE " & Right$(Request, (Len(Request) - i) + 1)
      Else
        Request &= " COLLATE NOCASE"
      Endif
    Endif
  Endif
  
  ''Ajout de fonctions 
  '<n colonne => transforme colonne en numérique et remplace null par 0
  '<c colonne => transforme numérique en chaine (remplace le . par la ,)
  '<s colonne => fait la somme de la colonne
  '<i colonne => retourne un numérique non signé si colonne < 0 sinon retourne 0
  '<p colonne => retourne un numérique si colonne > 0 sinon retourne 0
  ' exemple : SELECT <s qte_ligbl as qte FROM Fiches_LigBl
  '           SELECT SUM(<i qte_ligbl ) as qtep, SUM(<p qte_ligbl ) as qtep  -- bien metre l'espace entre  qte_ligbl et )
  patrn = " *([(),.a-zA-Z0-9_-]+) "
  If UCase(Request) Match "<S" Then Request = regex.Replace(Request, "<s" & patrn, "SUM(<n &1 ) ", regex.Caseless)
  If UCase(Request) Match "<C" Then Request = regex.Replace(Request, "<c" & patrn, "REPLACE(&1,'.',',') ", regex.Caseless)
  If UCase(Request) Match "<I" Then Request = RegExp.Replace(Request, "<i" & patrn, "CASE WHEN REPLACE(&1,',','.') < '0' THEN REPLACE(&1,',','.') * -1 ELSE '0' END ", regex.Caseless)
  If UCase(Request) Match "<P" Then Request = RegExp.Replace(Request, "<p" & patrn, "CASE WHEN REPLACE(&1,',','.') > '0' THEN REPLACE(&1,',','.') ELSE '0' END ", regex.Caseless)
  If UCase(Request) Match "<N" Then Request = regex.Replace(Request, "<n" & patrn, "CASE WHEN &1 IS NULL THEN '0' ELSE REPLACE(&1,',','.') END ", regex.Caseless)
  
  'Une fois logger on execute la requete
  If Utils.db.Opened = True Then
    rResult = Super.Exec(Request)
    Return rResult
  Else
    'Message.Error("La connection a la Base de donnée est inexistante, Vérifier vos paramètres d'accès.") 
    Return Null
  Endif

End



Public Sub LockIncrement(Field As String, Table As String, Optional p_form As String = "0") As Result 
  
  Dim rResult As Result
  Dim rResult2 As Result
  Dim Value As Integer
  Dim ctx As Collection
   
  Utils.db.Exec("LOCK TABLES " & Table & " WRITE ")
  With utils
    rResult = Utils.db.Exec("Select " & Field & " FROM " & Table)
    If rResult.Available Then
      Value = Val(rResult[Field])
      Value = Value + 1
      Utils.db.Exec("Update " & Table & " set " & Field & " = &1", Format(Value, p_form))
    Endif
  End With
  rResult2 = Utils.db.Exec("Select " & Field & " FROM " & Table)
  If rResult.Available And rResult.Available Then
    If Val(rResult2[Field]) - Val(rResult[Field]) <> 1 Then
      Message.Error("Erreur lors de l'increment du champ " & Field & " dans la table " & Table)
    Endif
  Else
    Message.Error("Impossible d'incrementer le champ " & Field & " dans la table " & Table)
  Endif
  Utils.db.Exec("UNLOCK TABLES")
  
  Return rResult2
  
End


Public Sub Create(Table As String) As Result 
  
  Dim rResult As Result
  Dim Backtrace As String[]

  If Is_Filtered("Exec_SQL", "Create " & Table) = True Then
    Backtrace = System.Backtrace
    Backtrace.Extract(Backtrace.Length - 1, -1)
    Backtrace.Extract(0, 1)
    If log.Enabled Then
      log.Log("Exec_SQL;" & user_name & ";" & host_id & ";" & machine_id & ";" & process_id & ";" & Backtrace.Join(",") & ";" & "Create " & Table)
    Endif
  Endif

  'Une fois logger on execute la requete
  If Super.Opened = True Then
    rResult = Super.Create(Table)
    Return rResult
  Else
    'Message.Error("La connection a la Base de donnée est inexistante, Vérifier vos paramètres d'accès.") 
    Return Null
  Endif

End

Public Sub Edit(Table As String, Request As String, ...) As Result 
  
  Dim rResult As Result
  Dim aArg As Variant[]
  Dim oneArg As Variant
  Dim Backtrace As String[]
  Dim iInd As Integer

  'This should work but it doen't because Param is a class... not a Argument Array.
  'rResult = Super.Exec(Request, Param)
  'Workaround below

  If Param.Count Then
    aArg = New Variant[Param.Count + 1]
    aArg[0] = Request
    iInd = 1
    For Each oneArg In Param
      aArg[iInd] = oneArg
      iInd += 1
    Next
    'Seul moyen trouvé pour executer une fonction a arg variable depuis une fonction a arg variable
    Request = Object.Call(Me, "Subst", aArg)
  Endif

  If Is_Filtered("Exec_SQL", "Edit " & Table & " : " & Request) = True Then
    Backtrace = System.Backtrace
    Backtrace.Extract(Backtrace.Length - 1, -1)
    Backtrace.Extract(0, 1)
    If log.Enabled Then
      log.Log("Exec_SQL;" & user_name & ";" & host_id & ";" & machine_id & ";" & process_id & ";" & Backtrace.Join(",") & ";" & "Edit " & Table & " : " & Request)
    Endif
  Endif

  'Une fois logger on execute la requete
  If Super.Opened = True Then
    rResult = Super.Edit(Table, Request)
    Return rResult
  Else
    'Message.Error("La connection a la Base de donnée est inexistante, Vérifier vos paramètres d'accès.") 
    Return Null
  Endif

End


Public Sub GUI_Event(hCont As Variant, Source As Variant[], Act As String, Value As Variant) 
  
  Dim Backtrace As String[]
  Dim Request As String = Act & "=" & CStr(Value) & "@" & hCont.Name & "#"
  Dim Ctrl As Variant
  
  For Each Ctrl In Source
    Request &= Ctrl.Name & "#"
  Next

  If Is_Filtered("GUI", Request) = True Then
    Backtrace = System.Backtrace
    'Backtrace.Extract(Backtrace.Length - 1, -1)
    Backtrace.Extract(0, 2)
    If log.Enabled Then
      log.Log("GUI;" & user_name & ";" & host_id & ";" & machine_id & ";" & process_id & ";" & Backtrace.Join(",") & ";" & Request)
    Endif
  Endif

End

Public Sub Close()
  
  Super.Close()
  Try log.Close()
  
End
